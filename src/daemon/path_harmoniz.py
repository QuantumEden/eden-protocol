#!/usr/bin/env python3
"""
Path Harmoniz ‚Äì Eden Protocol Import Hook

A runtime import hook that dynamically resolves import paths for the Eden Protocol repository.
Properly handles __file__, symbolic paths, and custom loaders for inner structure resolution.

Author: Manus (Adapted & Standardized)
"""

import os
import sys
import types
import importlib.abc
import importlib.util
import importlib.machinery
from pathlib import Path

REPO_ROOT = Path(__file__).parent.parent.resolve()

MODULE_MAPPING = {
    # Core meritcoin modules (multi-path support)
    'infra.xp.meritcoin_ledger': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_ledger.py'),
    'infra.xp.meritcoin_minter': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_minter.py'),
    'xp.meritcoin_ledger': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_ledger.py'),
    'xp.meritcoin_minter': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_minter.py'),
    'src.xp.meritcoin_ledger': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_ledger.py'),
    'src.xp.meritcoin_minter': str(REPO_ROOT / 'infra' / 'xp' / 'meritcoin_minter.py'),
}

class HarmonizFinder(importlib.abc.MetaPathFinder):
    """
    Custom import finder to reroute Eden Protocol symbolic modules.
    """

    def find_spec(self, fullname, path, target=None):
        if fullname in MODULE_MAPPING:
            filepath = MODULE_MAPPING[fullname]
            if os.path.exists(filepath):
                loader = HarmonizLoader(fullname, filepath)
                return importlib.machinery.ModuleSpec(fullname, loader, origin=filepath)
        return None

class HarmonizLoader(importlib.abc.Loader):
    """
    Custom loader that sets __file__, __package__, and executes the module.
    """

    def __init__(self, fullname, path):
        self.fullname = fullname
        self.path = path

    def create_module(self, spec):
        module = types.ModuleType(self.fullname)
        module.__file__ = self.path
        module.__loader__ = self
        module.__package__ = self.fullname.rpartition('.')[0]
        module.__path__ = []
        module.__spec__ = spec
        return module

    def exec_module(self, module):
        with open(self.path, 'rb') as f:
            code = compile(f.read(), self.path, 'exec')
        exec(code, module.__dict__)

def install_path_harmoniz():
    """
    Installs Harmoniz into Python's import system and ensures module paths are injected.
    """
    sys.meta_path.insert(0, HarmonizFinder())

    # Inject root and critical paths
    repo_str = str(REPO_ROOT)
    if repo_str not in sys.path:
        sys.path.insert(0, repo_str)

    xp_path = str(REPO_ROOT / 'infra' / 'xp')
    if xp_path not in sys.path:
        sys.path.insert(0, xp_path)

    # Ensure __init__.py files for symbolic resolution
    for init_file in [
        REPO_ROOT / 'infra' / '__init__.py',
        REPO_ROOT / 'infra' / 'xp' / '__init__.py',
    ]:
        if not init_file.exists():
            init_file.parent.mkdir(parents=True, exist_ok=True)
            with open(init_file, 'w') as f:
                f.write('# Auto-generated by Harmoniz\n')

    print("‚úÖ Path Harmoniz active")
    print(f"üìç Root: {REPO_ROOT}")
    print(f"üîó Modules rerouted: {len(MODULE_MAPPING)}")

if __name__ == "__main__":
    install_path_harmoniz()

    if len(sys.argv) > 1:
        modname = sys.argv[1]
        sys.argv = sys.argv[1:]
        try:
            mod = importlib.import_module(modname)
            if hasattr(mod, 'main') and callable(mod.main):
                mod.main()
        except Exception as e:
            print(f"‚ùå Harmoniz Error in {modname}: {e}")
            sys.exit(1)
